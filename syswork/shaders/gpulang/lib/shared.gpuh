//------------------------------------------------------------------------------
//  shared.gpuh
//  (C) 2024 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------
#pragma once

#include <lib/std.gpuh>
#include <lib/util.gpuh>

const MAX_TEXTURES = 65535;
const NUM_CASCADES = 4;
const SHADOW_CASTER_COUNT = 16;

const FLT_MAX = 3.40282347E+38f;
const FLT_MIN = -3.40282347E+38f;

group(TICK_GROUP) binding(0) uniform Textures1D : [MAX_TEXTURES]* texture1D;
group(TICK_GROUP) binding(0) uniform Textures1DArray : [MAX_TEXTURES]* texture1DArray;
group(TICK_GROUP) binding(0) uniform Textures2D : [MAX_TEXTURES]* texture2D;
group(TICK_GROUP) binding(0) uniform Textures2DArray : [MAX_TEXTURES]* texture2DArray;
group(TICK_GROUP) binding(0) uniform Textures2DMS : [MAX_TEXTURES]* texture2DMS;
group(TICK_GROUP) binding(0) uniform Textures2DMSArray : [MAX_TEXTURES]* texture2DMSArray;
group(TICK_GROUP) binding(0) uniform Textures3D : [MAX_TEXTURES]* texture3D;
group(TICK_GROUP) binding(0) uniform TexturesCube : [MAX_TEXTURES]* textureCube;
group(TICK_GROUP) binding(0) uniform TexturesCubeArray : [MAX_TEXTURES]* textureCubeArray;
group(TICK_GROUP) sampler_state Basic2DSampler{};
group(TICK_GROUP) sampler_state PointSampler { Filter = FilterMode.Nearest; AddressU = AddressMode.Clamp; AddressV = AddressMode.Clamp; };
group(TICK_GROUP) sampler_state LinearSampler { Filter = FilterMode.Linear; AddressU = AddressMode.Clamp; AddressV = AddressMode.Clamp; };

sample2D(handle : u32, uniform samp : *sampler, uv : f32x2) f32x4
{
    return textureSample(Textures2D[handle], samp, uv);
}

sample2DLod(handle : u32, uniform samp : *sampler, uv : f32x2, lod : f32) f32x4
{
    return textureSampleLod(Textures2D[handle], samp, uv, lod);
}

sample2DGrad(handle : u32, uniform samp : *sampler, uv : f32x2, ddx : f32x2, ddy : f32x2) f32x4
{
    return textureSampleGrad(Textures2D[handle], samp, uv, ddx, ddy);
}

sample2DMS(handle : u32, uniform samp : *sampler, uv : f32x2) f32x4
{
    return textureSample(Textures2DMS[handle], samp, uv);
}

sample2DMSLod(handle : u32, uniform samp : *sampler, uv : f32x2, lod : f32) f32x4
{
    return textureSampleLod(Textures2DMS[handle], samp, uv, lod);
}

sample2DArray(handle : u32, uniform samp : *sampler, uvw : f32x3) f32x4
{
    return textureSample(Textures2DArray[handle], samp, uvw);
}

sample2DArrayLod(handle : u32, uniform samp : *sampler, uvw : f32x3, lod : f32) f32x4
{
    return textureSampleLod(Textures2DArray[handle], samp, uvw, lod);
}

sample3D(handle : u32, uniform samp : *sampler, uvw : f32x3) f32x4
{
    return textureSample(Textures3D[handle], samp, uvw);
}

sample3DLod(handle : u32, uniform samp : *sampler, uvw : f32x3, lod : f32) f32x4
{
    return textureSampleLod(Textures3D[handle], samp, uvw, lod);
}

sampleCube(handle : u32, uniform samp : *sampler, uvw : f32x3) f32x4
{
    return textureSample(TexturesCube[handle], samp, uvw);
}

sampleCubeLod(handle : u32, uniform samp : *sampler, uvw : f32x3, lod : f32) f32x4
{
    return textureSampleLod(TexturesCube[handle], samp, uvw, lod);
}

sample2DArrayShadow(handle : u32, uniform samp : *sampler, uv : f32x2, index : f32, depth : f32) f32
{
    return textureSampleCompare(Textures2DArray[handle], samp, f32x3(uv, index), depth);
}

fetch2D(handle : u32, uv : f32x2, lod : f32) f32x4
{
    return textureFetch(Textures2D[handle], uv, lod);
}

fetch2DArray(handle : u32, uvw : f32x3, lod : f32) f32x4
{
    return textureFetch(Textures2DArray[handle], uvw, lod);
}

fetch2DMS(handle : u32, uv : f32x2, lod : f32) f32x4
{
    return textureFetch(Textures2DMS[handle], uv, lod);
}

fetch3D(handle : u32, uvw : f32x3, lod : f32) f32x4
{
    return textureFetch(Textures3D[handle], uvw, lod);
}

fetchStencil(handle : u32, uv : f32x2, lod : f32) u32
{
    // fetch stencil texture as a single channel texture
    return castToU32(textureFetch(Textures2D[handle], uv, lod).r);
}

queryLod2D(handle : u32, uniform samp : *sampler, uv : f32x2) f32
{
    // query the mip level of a 2D texture at a given UV coordinate
    return textureGetSampledMip(Textures2D[handle], samp, uv);
}

// these parameters are updated once per application tick
struct TickParams
{
    WindDirection : f32x4;

    WindWaveSize : f32;
    WindSpeed : f32;
    WindIntensity : f32;
    WindForce : f32;

    Saturation : f32;
    MaxLuminance : f32;
    FadeValue : f32;
    UseDof : u32;

    Balance : f32x4;

    DoFDistances : f32x3;
    EnableTerrainShadows : u32;

    BloomColor : f32x3;
    BloomIntensity : f32;
    
    FogDistances : f32x4;
    FogColor : f32x4;

    // global light stuff
    GlobalLightFlags : u32;
    GlobalLightShadowIntensity : f32;
    GlobalLightShadowMapSize : f32x2;
    GlobalLightDirWorldspace : f32x4;
    GlobalLightColor : f32x4;
    GlobalAmbientLightColor : f32x4;
    CSMShadowMatrix : f32x4x4;

    GlobalLightShadowBuffer : u32;
    TerrainShadowBuffer : u32;
    NumEnvMips : i32;

    EnvironmentMap : u32;

    TerrainShadowMapSize : u32x2;
    InvTerrainSize : f32x2;
    TerrainShadowMapPixelSize : f32x2;

    // these params are for the Preetham sky model
    A : f32x4;
    B : f32x4;
    C : f32x4;
    D : f32x4;
    E : f32x4;
    Z : f32x4;

    RayleighFactor : f32;
    RayleighZenithLength : f32;
    RefractiveIndex : f32;
    DepolarizationFactor : f32;
    Molecules : f32;
    MieV : f32;
    MieCoefficient : f32;
    MieDirectionalG : f32;
    MieZenithLength : f32;
    Turbidity : f32;
    SunIntensityFactor : f32;
    SunIntensityFalloff : f32;
    SunDiscSize : f32;
    MieKCoefficient : f32x3;
    PrimaryColors : f32x3;
    TonemapWeight : f32;
    Lum : f32;

    // CSM params

    GlobalLightShadowBias : f32;

    NormalBuffer : u32;
    DepthBuffer : u32;
    SpecularBuffer : u32;
    IrradianceMap : u32;
    DepthBufferCopy : u32;

    ltcLUT0 : u32;
    ltcLUT1 : u32;
};
group(TICK_GROUP) uniform PerTickParams : *TickParams;

// contains the render_state of the camera (and time)
struct ViewParams
{
    View : f32x4x4;
    InvView : f32x4x4;
    ViewProjection : f32x4x4;
    Projection : f32x4x4;
    InvProjection : f32x4x4;
    InvViewProjection : f32x4x4;
    EyePos : f32x4;
    FocalLengthNearFar : f32x4; // x, y is focal length x/y, z, w is near/far planes
    Time_Random_Luminance_X : f32x4; // x is time, y is random, z is luminance, w is unused
};
group(FRAME_GROUP) uniform ViewConstants : *ViewParams;

struct ShadowViewParams
{
    CascadeOffset : [NUM_CASCADES]f32x4;
    CascadeScale : [NUM_CASCADES]f32x4;
    CascadeDistances : f32x4;
    ShadowTiles : [SHADOW_CASTER_COUNT / 4] i32x4;
    LightViewMatrix : [SHADOW_CASTER_COUNT] f32x4x4;
};

@Visibility("VS|CS|PS|RCS")
group(FRAME_GROUP) uniform ShadowViewConstants : *ShadowViewParams;

group(FRAME_GROUP) sampler_state ShadowSampler
{
    CompareEnabled = true;
    AddressU = AddressMode.Clamp;
    AddressV = AddressMode.Clamp;
};

group(FRAME_GROUP) sampler_state PointLightTextureSampler
{
    Filter = FilterMode.MinMagLinearMipPoint;
};

group(FRAME_GROUP) sampler_state SpotlightTextureSampler
{
    Filter = FilterMode.MinMagLinearMipPoint;
    AddressU = AddressMode.Border;
    AddressV = AddressMode.Border;
    Border = Color.Transparent;
};

//------------------------------------------------------------------------------
/**
        CLUSTERS
*/
//------------------------------------------------------------------------------
const CLUSTER_POINTLIGHT_BIT = 0x1u;
const CLUSTER_SPOTLIGHT_BIT = 0x2u;
const CLUSTER_AREALIGHT_BIT = 0x4u;
const CLUSTER_LIGHTPROBE_BIT = 0x8u;
const CLUSTER_PBR_DECAL_BIT = 0x10u;
const CLUSTER_EMISSIVE_DECAL_BIT = 0x20u;
const CLUSTER_FOG_SPHERE_BIT = 0x40u;
const CLUSTER_FOG_BOX_BIT = 0x80u;
const CLUSTER_GI_VOLUME_BIT = 0x100u;


// set a fixed number of cluster entries
const NUM_CLUSTER_ENTRIES = 16384;

struct ClusterAABB
{
    maxPoint : f32x4;
    minPoint : f32x4;
    featureFlags : u32;
};

@Visibility("VS|CS|PS|RCS")
group(FRAME_GROUP) uniform ClusterAABBs : [] *mutable ClusterAABB; 

// this is used to keep track of how many lights we have active
struct ClusterParams
{
    FramebufferDimensions : f32x2;
    InvFramebufferDimensions : f32x2;
    BlockSize : u32x2;
    InvZScale : f32;
    InvZBias : f32;

    NumCells : u32x3;
    ZDistribution : f32;
};

@Visibility("VS|CS|PS|RCS")
group(FRAME_GROUP) uniform ClusterUniforms : *ClusterParams;

//------------------------------------------------------------------------------
/**
        LIGHTS
*/
//------------------------------------------------------------------------------

// increase if we need more lights in close proximity, for now, 128 is more than enough
const MAX_LIGHTS_PER_CLUSTER = 128;

struct SpotLight
{
    position : f32x3;				// view space position of light
    range : f32;
    forward : f32x3;				// forward vector of light (spotlight and arealights)
    angleFade : f32;

    angleSinCos : f32x2;			// angle cutoffs
    projectionExtension : i32;	// projection extension index
    shadowExtension : i32;		// projection extension index

    color : f32x3;					// light color
    flags : u32;					// feature flags (shadows, projection texture, etc)
};

struct SpotLightProjectionExtension
{
    projection : f32x4x4;					// projection transform
    projectionTexture : u32;	// projection texture
};

struct SpotLightShadowExtension
{
    projection : f32x4x4;
    shadowIntensity : f32;				// intensity of shadows
    shadowSlice : u32;
    shadowMap : u32;			// shadow map
};

struct PointLight
{
    position : f32x3;				// view space position of light, w is range
    range : f32;

    color : f32x3;					// light color
    flags : u32;					// feature flags (shadows, projection texture, etc)
};

struct PointLightShadowExtension
{
    shadowIntensity : f32;		// intensity of shadows
    shadowMap : u32;				// shadow map
};

struct AreaLight
{
    bboxMin : f32x3;               // Bounding box min point
    range : f32;
    bboxMax : f32x3;               // Bounding box max point
    radius : f32;

    xAxis : f32x3;
    width : f32;
    yAxis : f32x3;
    height : f32;
    position : f32x3;
    flags : u32;

    color : f32x3;					// light color
    shadowExtension : i32;		// projection extension index
};

struct AreaLightShadowExtension
{
    projection : f32x4x4;
    shadowIntensity : f32;				// intensity of shadows
    shadowSlice : u32;
    shadowMap : u32;			// shadow map
};

struct LightParams
{
    SSAOBuffer : u32;
    NumPointLights : u32;
    NumSpotLights : u32;
    NumAreaLights : u32;
    NumLightClusters : u32;
};

@Visibility("VS|CS|PS")
group(FRAME_GROUP) uniform LightUniforms : *LightParams;

// contains amount of lights, and the index of the light (pointing to the indices in PointLightList and SpotLightList), to output
struct LightIndexData
{
    PointLightCountList : [NUM_CLUSTER_ENTRIES] u32;
    PointLightIndexList : [NUM_CLUSTER_ENTRIES * MAX_LIGHTS_PER_CLUSTER] u32;
    SpotLightCountList : [NUM_CLUSTER_ENTRIES] u32;
    SpotLightIndexList : [NUM_CLUSTER_ENTRIES * MAX_LIGHTS_PER_CLUSTER] u32;
    AreaLightCountList : [NUM_CLUSTER_ENTRIES] u32;
    AreaLightIndexList : [NUM_CLUSTER_ENTRIES * MAX_LIGHTS_PER_CLUSTER] u32;
};

@Visibility("VS|CS|PS|RCS")
group(FRAME_GROUP) uniform LightIndexLists : *mutable LightIndexData;

struct LightListData
{
    SpotLights : [1024]SpotLight;
    SpotLightProjection : [256]SpotLightProjectionExtension;
    SpotLightShadow : [16]SpotLightShadowExtension;
    PointLights : [1024]PointLight;
    PointLightShadow : [16]PointLightShadowExtension;
    AreaLights : [1024]AreaLight;
    AreaLightShadow : [16]AreaLightShadowExtension;
};

@Visibility("VS|CS|PS|RCS")
group(FRAME_GROUP) uniform LightLists : *mutable LightListData;

//------------------------------------------------------------------------------
/**
        DECALS
*/
//------------------------------------------------------------------------------
// increase if we need more decals in close proximity, for now, 128 is more than enough
const MAX_DECALS_PER_CLUSTER = 128;

struct PBRDecal
{
    albedo : u32;
    bboxMin : f32x4;
    bboxMax : f32x4;
    invModel : f32x4x4;
    direction : f32x3;
    material : u32;
    tangent : f32x3;
    normal : u32;
};

struct EmissiveDecal
{
    bboxMin : f32x4;
    bboxMax : f32x4;
    invModel : f32x4x4;
    direction : f32x3;
    emissive : u32;
};


// this is used to keep track of how many lights we have active
struct DecalParams
{
    NumPBRDecals : u32;
    NumEmissiveDecals : u32;
    NumDecalClusters : u32;
    NormalBufferCopy : u32;
    StencilBuffer : u32;
};

@Visibility("CS|PS")
group(FRAME_GROUP) uniform DecalUniforms : *DecalParams;

// contains amount of lights, and the index of the light (pointing to the indices in PointLightList and SpotLightList), to output
struct DecalIndexData
{
    EmissiveDecalCountList : [NUM_CLUSTER_ENTRIES] u32;
    EmissiveDecalIndexList : [NUM_CLUSTER_ENTRIES * MAX_DECALS_PER_CLUSTER] u32;
    PBRDecalCountList : [NUM_CLUSTER_ENTRIES] u32;
    PBRDecalIndexList : [NUM_CLUSTER_ENTRIES * MAX_DECALS_PER_CLUSTER] u32;
};

@Visibility("CS|PS")
group(FRAME_GROUP) uniform DecalIndexLists : *mutable DecalIndexData;

struct DecalListData
{
    EmissiveDecals : [128] EmissiveDecal;
    PBRDecals : [128] PBRDecal;
};

@Visibility("CS|PS")
group(FRAME_GROUP) uniform DecalLists : *mutable DecalListData;

//------------------------------------------------------------------------------
/**
        VOLUME FOG
*/
//------------------------------------------------------------------------------


struct FogSphere
{
    position : f32x3;
    radius : f32;
    absorption : f32x3;
    turbidity : f32;
    falloff : f32;
};

struct FogBox
{
    bboxMin : f32x3;
    falloff : f32;
    bboxMax : f32x3;
    turbidity : f32;
    absorption : f32x3;
    invTransform : f32x4x4;
};

// increase if we need more decals in close proximity, for now, 128 is more than enough
const MAX_FOGS_PER_CLUSTER = 128;

// this is used to keep track of how many lights we have active
struct VolumeFogParams
{
    DownscaleFog : i32;
    NumFogSpheres : u32;
    NumFogBoxes : u32;
    NumVolumeFogClusters : u32;
    GlobalAbsorption : f32x3;
    GlobalTurbidity : f32;
};

@Visibility("CS|VS|PS")
group(FRAME_GROUP) uniform VolumeFogUniforms : *VolumeFogParams;

// contains amount of lights, and the index of the light (pointing to the indices in PointLightList and SpotLightList), to output
struct FogIndexListData
{
    FogSphereCountList : [NUM_CLUSTER_ENTRIES] u32;
    FogSphereIndexList : [NUM_CLUSTER_ENTRIES * MAX_FOGS_PER_CLUSTER] u32;
    FogBoxCountList : [NUM_CLUSTER_ENTRIES] u32;
    FogBoxIndexList : [NUM_CLUSTER_ENTRIES * MAX_FOGS_PER_CLUSTER] u32;
};

@Visibility("CS|VS|PS")
group(FRAME_GROUP) uniform FogIndexLists : *mutable FogIndexListData;

struct FogListData
{
    FogSpheres : [128] FogSphere;
    FogBoxes : [128] FogBox;
};

@Visibility("CS|VS|PS")
group(FRAME_GROUP) uniform FogLists : *mutable FogListData;

//------------------------------------------------------------------------------
/**
        GI
*/
//------------------------------------------------------------------------------
struct GIVolume
{
    bboxMin : f32x3;
    NumDistanceTexels : i32;
    bboxMax : f32x3; 
    EncodingGamma : f32;
    Offset : f32x3;
    Irradiance : u32;
    Rotation : f32x4; // quaternion
    GridCounts : i32x3;
    Distances : u32;
    GridSpacing : f32x3;
    Offsets : u32;
    ScrollOffsets : i32x3;
    NumIrradianceTexels : i32;
    Size : f32x3;
    States : u32;
    
    BlendCutoff : f32;
    Blend : f32;
    
    NormalBias : f32;
    ViewBias : f32;
    IrradianceScale : f32;
    Options : u32;
};
const MAX_GI_VOLUMES_PER_CLUSTER = 4;

struct GIVolumeParams
{
    NumGIVolumes : u32;
    NumGIVolumeClusters : u32;
};
@Visibility("CS|PS")
group(FRAME_GROUP) uniform GIVolumeUniforms : *GIVolumeParams;

struct GIIndexListData
{
    GIVolumeCountList : [NUM_CLUSTER_ENTRIES]u32;
    GIVolumeIndexLists : [NUM_CLUSTER_ENTRIES * MAX_GI_VOLUMES_PER_CLUSTER]u32;
};

struct GIVolumeListData
{
    GIVolumes : [64]GIVolume;
};

@Visibility("CS|VS|PS")
group(FRAME_GROUP) uniform GIIndexLists : *mutable GIIndexListData;

@Visibility("CS|VS|PS")
group(FRAME_GROUP) uniform GIVolumeLists : *mutable GIVolumeListData;

//------------------------------------------------------------------------------
/**
        Passes
*/
//------------------------------------------------------------------------------
group(PASS_GROUP) uniform InputAttachment0 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment1 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment2 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment3 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment4 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment5 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment6 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment7 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment8 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment9 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment10 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment11 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment12 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment13 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment14 : *pixelCache;
group(PASS_GROUP) uniform InputAttachment15 : *pixelCache;
group(PASS_GROUP) uniform DepthAttachment : *pixelCache;

struct RenderTargetParameters
{
    Dimensions : f32x4;    // render target dimensions are size (xy) inversed size (zw)
    Scale : f32x2;         // dimensions / viewport
};

struct PassParameters
{
    RenderTargets : [16]RenderTargetParameters;
};

group(PASS_GROUP) uniform PassUniforms : *PassParameters;

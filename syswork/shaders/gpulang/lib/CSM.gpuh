//------------------------------------------------------------------------------
//  CSM.gpuh
//  (C) 2025 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------

#ifndef CSM_GPUH
#define CSM_GPUH

//#define CSM_DEBUG

#include <lib/shadowbase.gpuh>
#include <lib/std.gpuh>

const DebugColors : [8]f32x4 =
[
    f32x4 (1.5f, 0.0f, 0.0f, 1.0f),
    f32x4 (0.0f, 1.5f, 0.0f, 1.0f),
    f32x4 (0.0f, 0.0f, 5.5f, 1.0f),
    f32x4 (1.5f, 0.0f, 5.5f, 1.0f),
    f32x4 (1.5f, 1.5f, 0.0f, 1.0f),
    f32x4 (1.0f, 1.0f, 1.0f, 1.0f),
    f32x4 (0.0f, 1.0f, 5.5f, 1.0f),
    f32x4 ( 0.5f, 3.5f, 0.75f, 1.0f )
];

//------------------------------------------------------------------------------
/**
	CSM shadow sampling entry point
*/
CSMPS(
	  TexShadow : f32x4
	, Texture : u32
#ifdef CSM_DEBUG
	, Debug : *f32x4
#endif
) f32
{
	var texCoordShadow = f32x4(0.0f);
	var cascadeFound = false;

    TexShadow = TexShadow / TexShadow.wwww;
    const uvDdx = ddx(TexShadow.xy);
    const uvDdy = ddy(TexShadow.xy);

	var cascadeIndex : i32 = 0;
	for(; cascadeIndex < NUM_CASCADES; ++cascadeIndex)
	{
		texCoordShadow = mad(TexShadow, ShadowViewConstants.CascadeScale[cascadeIndex], ShadowViewConstants.CascadeOffset[cascadeIndex]);

		if ( min( texCoordShadow.x, texCoordShadow.y ) >= 0.0f
		  && max( texCoordShadow.x, texCoordShadow.y ) <= 1.0f )
		{
			cascadeFound = true;
			break;
		}
	}

#ifdef CSM_DEBUG
	*Debug = DebugColors[cascadeIndex];
#endif

	// if we have no matching cascade, return with a fully lit pixel
	if (!cascadeFound)
	{
		return 1.0f;
	}

	// calculate texture coordinate in shadow space
	const occlusion = PCFShadowArray(Texture, texCoordShadow.z, texCoordShadow.xy, cascadeIndex, PerTickParams.GlobalLightShadowMapSize.xy);
	return occlusion;
}

#endif

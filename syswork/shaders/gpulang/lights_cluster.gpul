//------------------------------------------------------------------------------
//  lights_cluster.gpul
//  (C) 2019 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------
#include <lib/std.gpuh>
#include <lib/util.gpuh>
#include <lib/shared.gpuh>
#include <lib/clustering.gpuh>
#include <lib/lighting_functions.gpuh>

uniform Lighting : *mutable rgba16f texture2D;
uniform DebugOutput : *mutable rgba16f texture2D;

//------------------------------------------------------------------------------
/**
*/
local_size_x(64)
entry_point
csCull() void
{
    const index1D = computeGetGlobalThreadIndices().x;

    if index1D > LightUniforms.NumLightClusters { return; }

    const aabb = bufferLoad(ClusterAABBs, index1D); 

    var flags = 0u;

    // update pointlights
    var numLights = 0u;
    for (var i = 0u; i < LightUniforms.NumPointLights; i++)
    {
        const light = LightLists.PointLights[i];
        const viewSpacePos = (ViewConstants.View * f32x4(light.position, 1)).xyz;
        if (TestAABBSphere(aabb, viewSpacePos, light.range))
        {
            LightIndexLists.PointLightIndexList[index1D * MAX_LIGHTS_PER_CLUSTER + numLights] = i;
            numLights++;
        }
    }
    LightIndexLists.PointLightCountList[index1D] = numLights;

    // update feature flags if we have any lights
    if numLights > 0 { flags |= CLUSTER_POINTLIGHT_BIT; }

    // update spotlights
    numLights = 0u;
    for (var i = 0u; i < LightUniforms.NumSpotLights; i++)
    {
        const light = LightLists.SpotLights[i];
        // first do fast discard sphere test
        const viewSpacePos = (ViewConstants.View * f32x4(light.position, 1)).xyz;
        //if (TestAABBSphere(aabb, viewSpacePos, light.range))
        {
            // then do more refined cone test, if previous test passed
            const viewSpaceForward = (ViewConstants.View * f32x4(light.forward, 0)).xyz;
            //if (TestAABBCone(aabb, viewSpacePos, viewSpaceForward, light.range, light.angleSinCos))
            {
                LightIndexLists.SpotLightIndexList[index1D * MAX_LIGHTS_PER_CLUSTER + numLights] = i;
                numLights++;
            }
        }       
    }
    LightIndexLists.SpotLightCountList[index1D] = numLights;

    // update feature flags if we have any lights
    if numLights > 0 { flags |= CLUSTER_SPOTLIGHT_BIT; }

    numLights = 0u;
    for (var i = 0u; i < LightUniforms.NumAreaLights; i++)
    { 
        const light = LightLists.AreaLights[i];
        //const viewSpaceCenter = (ViewConstants.View * f32x4(light.position, 1)).xyz;

        //vec3 maxExtents = vec3(max(max(viewSpaceExtents.x, viewSpaceExtents.y), viewSpaceExtents.z));
        const viewSpaceMin = (ViewConstants.View * f32x4(light.bboxMin, 1)).xyz;
        const viewSpaceMax = (ViewConstants.View * f32x4(light.bboxMax, 1)).xyz;
        if (TestAABBAABB(aabb, viewSpaceMin, viewSpaceMax))
        {
            LightIndexLists.AreaLightIndexList[index1D * MAX_LIGHTS_PER_CLUSTER + numLights] = i;
            numLights++;
        }
    }
    LightIndexLists.AreaLightCountList[index1D] = numLights;

    if numLights > 0 { flags |= CLUSTER_AREALIGHT_BIT; }

    atomicOr(&bufferPtr(ClusterAABBs, index1D).featureFlags, flags, MemorySemantics.Acquire);
}

//------------------------------------------------------------------------------
/**
*/
local_size_x(64)
entry_point
csDebug() void
{
    const coord = i32x2(computeGetGlobalThreadIndices().xy);
    const depth = fetch2D(PerTickParams.DepthBuffer, coord, 0).r;

    // convert screen coord to view-space position
    const worldPos = PixelToWorld(coord * ClusterUniforms.InvFramebufferDimensions, depth, ViewConstants.InvView, ViewConstants.InvProjection);

    const index3D = CalculateClusterIndex(coord / ClusterUniforms.BlockSize, worldPos.z, ClusterUniforms.InvZScale, ClusterUniforms.InvZBias);
    const idx = Pack3DTo1D(index3D, ClusterUniforms.NumCells.x, ClusterUniforms.NumCells.y);

    const flag = bufferLoad(ClusterAABBs, idx).featureFlags;
    var color = f32x4(0, 0, 0, 0);
    if (CheckFlags(flag, CLUSTER_POINTLIGHT_BIT))
    {
        const count = LightIndexLists.PointLightCountList[idx];
        color.r = count / f32(LightUniforms.NumPointLights);
    }
    if (CheckFlags(flag, CLUSTER_SPOTLIGHT_BIT))
    {
        const count = LightIndexLists.SpotLightCountList[idx];
        color.g = count / f32(LightUniforms.NumSpotLights);
    }
    if (CheckFlags(flag, CLUSTER_AREALIGHT_BIT))
    {
        const count = LightIndexLists.AreaLightCountList[idx];
        color.b = count / f32(LightUniforms.NumAreaLights);
    }
    
    textureStore(DebugOutput, i32x2(coord), color); 
}

//------------------------------------------------------------------------------
/**
*/
@Mask("Cull")
program Cull
{
    ComputeShader = csCull;
};

//------------------------------------------------------------------------------
/**
*/
@Mask("Debug")
program Debug
{
    ComputeShader = csDebug;
};

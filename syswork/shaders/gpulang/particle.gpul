//------------------------------------------------------------------------------
//  particle.gpul
//  (C) 2013 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------

#include "lib/std.gpuh"
#include "lib/particles.gpuh"
#include "lib/shared.gpuh"
#include "lib/objects_shared.gpuh"
#include "lib/util.gpuh"
#include "lib/defaultsamplers.gpuh"
#include "lib/clustering.gpuh"
#include "lib/lighting_functions.gpuh"

#include <material_interfaces.gpul>

// samplers
sampler_state ParticleSampler
{
    Filter = MinMagMipLinear;
    AddressU = Wrap;
    AddressV = Wrap;
};

sampler_state LayerSampler
{
    AddressU = Mirror;
    AddressV = Mirror;
};

render_state LitParticleState
{
    BlendEnabled[0] = true;
    SrcBlend[0] = SrcAlpha;
    DstBlend[0] = OneMinusSrcAlpha;
    CullMode = None;
    DepthEnabled = true;
    DepthWrite = false;
    DepthFunc = Less;
};

render_state UnlitParticleState
{
    BlendEnabled[0] = true;
    SrcBlend[0] = SrcAlpha;
    DstBlend[0] = OneMinusSrcAlpha;
    
    CullMode = None;
    DepthEnabled = true;
    DepthWrite = false;
    DepthFunc = Less;
};

render_state UnlitAdditiveParticleState
{
    BlendEnabled[0] = true;
    SrcBlend[0] = SrcAlpha;
    DstBlend[0] = One;
    
    CullMode = None;
    DepthEnabled = true;
    DepthWrite = false;
    DepthFunc = Less;
};

render_state UnlitParticleStateBlendAdd
{
    BlendEnabled[0] = true;
    SrcBlend[0] = One;
    DstBlend[0] = OneMinusSrcAlpha;
    
    CullMode = None;
    DepthEnabled = true;
    DepthWrite = false;
    DepthFunc = Less;
};

//------------------------------------------------------------------------------
/**
*/
const stippleMasks : [4]f32x2 = [
        f32x2(0,0), 
        f32x2(1,0), 
        f32x2(0,1),
        f32x2(1,1)
        ];


//------------------------------------------------------------------------------
/**
*/
entry_point
vsUnlit(
    binding(0) in corner : f32x2,
    binding(1) in position : f32x4,
    binding(2) in stretchPos : f32x4,
    binding(3) in color : f32x4,
    binding(4) in uvMinMax : f32x4,
    binding(5) in rotSize : f32x4,
    out ViewSpacePos : : f32x4,
    out Color : : f32x4,
    out UV : f32x2) void
{
    CornerVertex cornerVert = ComputeCornerVertex(
                                        corner,
                                        position,
                                        stretchPos,
                                        uvMinMax,
                                        f32x2(rotSize.x, rotSize.y),
                                        rotSize.z);
                                        
    UV = cornerVert.UV;
    ViewSpacePos = ViewConstants.View * cornerVert.worldPos;
    Color = color;
    vertexExportCoordinates(ViewConstants.ViewProjection * cornerVert.worldPos);
}

//------------------------------------------------------------------------------
/**
*/
entry_point
vsLit(
    binding(0) in corner: f32x2,
    binding(1) in position : f32x4,
    binding(2) in stretchPos : f32x4,
    binding(3) in color : f32x4,
    binding(4) in uvMinMax : f32x4,
    binding(5) in rotSize : f32x4,
    out ViewSpacePos, : f32x4
    out Normal : f32x3,
    out Tangent : f32x3,
    out WorldEyeVec : f32x3,
    out Color : f32x4,
    out UV : f32x2) void
{
    CornerVertex cornerVert = ComputeCornerVertex(
                                        corner,
                                        position,
                                        stretchPos,
                                        uvMinMax,
                                        f32x2(rotSize.x, rotSize.y),
                                        rotSize.z);
                                        
    Normal = cornerVert.worldNormal;
    Tangent = cornerVert.worldTangent;
    UV = cornerVert.UV;
    WorldEyeVec = normalize(ViewConstants.EyePos - cornerVert.worldPos).xyz;
    ViewSpacePos = ViewConstants.View * cornerVert.worldPos;
    Color = color;
    vertexExportCoordinates(ViewConstants.ViewProjection * cornerVert.worldPos);
}

//------------------------------------------------------------------------------
/**
*/
shader
void
psUnlit(in ViewSpacePosition : f32x4,
    in Color : f32x4,
    in UV : f32x2,
    [color0] out FinalColor : f32x4)
{
    const pixelSize = RenderTargetParameter[0].Dimensions.zw;
    const screenUV = PixelToNormalized(gl_FragCoord.xy, pixelSize.xy);
    const diffColor = sample2D(_Unlit.AlbedoMap, ParticleSampler, UV);
    
    var color = diffColor * f32x4(Color.rgb, 0);
    const depth = sample2DLod(DepthBufferCopy, ParticleSampler, screenUV, 0).r;
    const AlphaMod = saturate(abs(depth - gl_FragCoord.z) * (FocalLengthNearFar.w - FocalLengthNearFar.z));
    color.a = diffColor.a * Color.a * AlphaMod;
    FinalColor = color;
}

//------------------------------------------------------------------------------
/**
*/
shader
void
psUnlit2Layers(in vec4 ViewSpacePosition,
    in vec4 Color,
    in vec2 UV,
    [color0] out vec4 FinalColor) 
{
    vec2 pixelSize = RenderTargetParameter[0].Dimensions.zw;
    vec2 screenUV = PixelToNormalized(gl_FragCoord.xy, pixelSize.xy);
    vec4 layer1 = sample2D(_BlendAdd.AlbedoMap, LayerSampler, UV + _BlendAdd.UVAnim1 * Time_Random_Luminance_X.x);
    vec4 layer2 = sample2D(_BlendAdd.Layer2, LayerSampler, UV + _BlendAdd.UVAnim2 * Time_Random_Luminance_X.x);
    
    vec4 color = layer1 * layer2 * 2;
    float depth = sample2DLod(DepthBufferCopy, ParticleSampler, screenUV, 0).r;
    float AlphaMod = saturate(abs(depth - gl_FragCoord.z) * (FocalLengthNearFar.w - FocalLengthNearFar.z));
    color.a = saturate(color.a);
    color.rgb += Color.rgb * color.a;
    color *= Color.a * AlphaMod;
    FinalColor = color;
}

//------------------------------------------------------------------------------
/**
*/
shader
void
psUnlit3Layers(in vec4 ViewSpacePosition,
    in vec4 Color,
    in vec2 UV,
    [color0] out vec4 FinalColor) 
{
    vec2 pixelSize = RenderTargetParameter[0].Dimensions.zw;
    vec2 screenUV = PixelToNormalized(gl_FragCoord.xy, pixelSize.xy);
    vec4 layer1 = sample2D(_BlendAdd.AlbedoMap, LayerSampler, UV + _BlendAdd.UVAnim1 * Time_Random_Luminance_X.x);
    vec4 layer2 = sample2D(_BlendAdd.Layer2, LayerSampler, UV + _BlendAdd.UVAnim2 * Time_Random_Luminance_X.x);
    vec4 layer3 = sample2D(_BlendAdd.Layer3, LayerSampler, UV + _BlendAdd.UVAnim3 * Time_Random_Luminance_X.x);
    
    vec4 color = ((layer1 * layer2 * 2) * layer3 * 2);
    float depth = sample2DLod(DepthBufferCopy, ParticleSampler, screenUV, 0).r;
    float AlphaMod = saturate(abs(depth - gl_FragCoord.z) * (FocalLengthNearFar.w - FocalLengthNearFar.z));
    color.a = saturate(color.a);
    color.rgb += Color.rgb * color.a;
    color *= Color.a * AlphaMod;
    FinalColor = color;
}

//------------------------------------------------------------------------------
/**
*/
shader
void
psUnlit4Layers(in vec4 ViewSpacePosition,
    in vec4 Color,
    in vec2 UV,
    [color0] out vec4 FinalColor) 
{
    vec2 pixelSize = RenderTargetParameter[0].Dimensions.zw;
    vec2 screenUV = PixelToNormalized(gl_FragCoord.xy, pixelSize.xy);
    vec4 layer1 = sample2D(_BlendAdd.AlbedoMap, LayerSampler, UV + _BlendAdd.UVAnim1 * Time_Random_Luminance_X.x);
    vec4 layer2 = sample2D(_BlendAdd.Layer2, LayerSampler, UV + _BlendAdd.UVAnim2 * Time_Random_Luminance_X.x);
    vec4 layer3 = sample2D(_BlendAdd.Layer3, LayerSampler, UV + _BlendAdd.UVAnim3 * Time_Random_Luminance_X.x);
    vec4 layer4 = sample2D(_BlendAdd.Layer4, LayerSampler, UV + _BlendAdd.UVAnim4 * Time_Random_Luminance_X.x);
    
    vec4 color = ((layer1 * layer2 * 2) * layer3 * 2) * layer4;
    float depth = sample2DLod(DepthBufferCopy, ParticleSampler, screenUV, 0).r;
    float AlphaMod = saturate(abs(depth - gl_FragCoord.z) * (FocalLengthNearFar.w - FocalLengthNearFar.z));
    color.a = saturate(color.a);
    color.rgb += Color.rgb * color.a;
    color *= Color.a * AlphaMod;
    FinalColor = color;
}

//------------------------------------------------------------------------------
/**
*/
shader
void
psLit(in vec4 ViewSpacePosition,
    in vec3 Normal,
    in vec3 Tangent,
    in vec3 WorldEyeVec,
    in vec4 Color,
    in vec2 UV,
    [color0] out vec4 Light) 
{   
    vec4 albedo =       sample2D(_BSDF.AlbedoMap, ParticleSampler, UV);
    vec4 material =     sample2D(_BSDF.ParameterMap, ParticleSampler, UV);
    
    const float depth = fetch2D(DepthBufferCopy, ParticleSampler, ivec2(gl_FragCoord.xy), 0).r;
    const float particleDepth = gl_FragCoord.z;
    float AlphaMod = saturate(abs(depth - particleDepth) * (FocalLengthNearFar.w - FocalLengthNearFar.z));
    const float finalAlpha = albedo.a * Color.a * AlphaMod;
    if (finalAlpha < 0.001f)
        discard;

    vec3 tNormal = vec3(0,0,0);

    tNormal.xy = (sample2D(_BSDF.NormalMap, ParticleSampler, UV).ag * 2.0) - 1.0;
    tNormal.z = saturate(sqrt(1.0 - dot(tNormal.xy, tNormal.xy)));
    vec3 binormal = cross(Normal.xyz, Tangent.xyz);

    if (!gl_FrontFacing)
    {
        // flip tangent space if backface, and transform normal
        tNormal = mat3(Tangent.xyz, binormal.xyz, -Normal.xyz) * tNormal;
    }
    else
    {
        // transform normal to tangent space
        tNormal = mat3(Tangent.xyz, binormal.xyz, Normal.xyz) * tNormal;
    }

    // calculate cluster index
    uint3 index3D = CalculateClusterIndex(gl_FragCoord.xy / BlockSize, ViewSpacePosition.z, InvZScale, InvZBias);
    uint idx = Pack3DTo1D(index3D, NumCells.x, NumCells.y);

    vec3 light = vec3(0, 0, 0);

    // add light
    light += CalculateGlobalLightAmbientTransmission(ViewSpacePosition.xyz, WorldEyeVec, tNormal.xyz, particleDepth, material, albedo, _BSDF.Transmission);
    vec3 viewVec = -normalize(ViewSpacePosition.xyz);
    vec3 viewNormal = (View * vec4(tNormal.xyz, 0)).xyz;
    light += LocalLightsAmbientTransmission(idx, ViewSpacePosition, viewVec, viewNormal, particleDepth, material, albedo, _BSDF.Transmission);
    
    Light = vec4(light, finalAlpha);
}

//------------------------------------------------------------------------------
/**
*/
SimpleTechnique(Unlit, "Unlit", vsUnlit(), psUnlit(), UnlitParticleState);
SimpleTechnique(UnlitAdditive, "Unlit|Alt0", vsUnlit(), psUnlit(), UnlitAdditiveParticleState);
SimpleTechnique(UnlitBlendAdd, "Unlit|Alt1", vsUnlit(), psUnlit(), UnlitParticleStateBlendAdd);
SimpleTechnique(UnlitBlendAdd2Layers, "Unlit|Alt2", vsUnlit(), psUnlit2Layers(), UnlitParticleStateBlendAdd);
SimpleTechnique(UnlitBlendAdd3Layers, "Unlit|Alt3", vsUnlit(), psUnlit3Layers(), UnlitParticleStateBlendAdd);
SimpleTechnique(UnlitBlendAdd4Layers, "Unlit|Alt4", vsUnlit(), psUnlit4Layers(), UnlitParticleStateBlendAdd);
SimpleTechnique(Lit, "Static", vsLit(), psLit(), LitParticleState);
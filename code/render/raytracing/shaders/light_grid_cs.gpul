//------------------------------------------------------------------------------
//  @file light_grid_cs.gpul
//  @copyright (C) 2026 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------
#include <lib/shared.gpuh>
#include <lib/clustering.gpuh>

//------------------------------------------------------------------------------
/**
*/
local_size_x(64)
entry_point
csCull() void
{
    const index1D = computeGetGlobalThreadIndices().x;

    if (index1D > LightUniforms.NumLightClusters) { return; }

    const aabb = bufferLoad(ClusterAABBs, index1D);

    var flags = 0u;

    // update pointlights
    var numLights = 0u;
    for (var i = 0u; i < LightUniforms.NumPointLights; i++)
    {
        const light = LightLists.PointLights[i];
        if (TestAABBSphere(aabb, light.position, light.range))
        {
            LightIndexLists.PointLightIndexList[index1D * MAX_LIGHTS_PER_CLUSTER + numLights] = i;
            numLights++;
        }
    }
    LightIndexLists.PointLightCountList[index1D] = numLights;

    // update feature flags if we have any lights
    if (numLights > 0)
	{
        flags |= CLUSTER_POINTLIGHT_BIT;
	}

    // update spotlights
    numLights = 0u;
    for (var i = 0u; i < LightUniforms.NumSpotLights; i++)
    {
        const light = LightLists.SpotLights[i];
        // first do fast discard sphere test
        if (TestAABBSphere(aabb, light.position, light.range))
        {
            // then do more refined cone test, if previous test passed
            if (TestAABBCone(aabb, light.position, light.forward, light.range, light.angleSinCos))
            {
                LightIndexLists.SpotLightIndexList[index1D * MAX_LIGHTS_PER_CLUSTER + numLights] = i;
                numLights++;
            }
        }
    }
    LightIndexLists.SpotLightCountList[index1D] = numLights;

    // update feature flags if we have any lights
    if (numLights > 0) { flags |= CLUSTER_SPOTLIGHT_BIT; }

    numLights = 0u;
    for (var i = 0u; i < LightUniforms.NumAreaLights; i++)
    {
        const light = LightLists.AreaLights[i];
        const worldSpaceMin = light.position - light.bboxMin;
        const worldSpaceMax = light.position + light.bboxMax;
        if (TestAABBAABB(aabb, worldSpaceMin, worldSpaceMax))
        {
            LightIndexLists.AreaLightIndexList[index1D * MAX_LIGHTS_PER_CLUSTER + numLights] = i;
            numLights++;
        }
    }
    LightIndexLists.AreaLightCountList[index1D] = numLights;

    if (numLights > 0) { flags |= CLUSTER_AREALIGHT_BIT; }

    atomicOr(&bufferPtr(ClusterAABBs, index1D).featureFlags, flags, MemorySemantics.Acquire);
}

//------------------------------------------------------------------------------
/**
*/
local_size_x(64)
entry_point
csClusterAABB() void 
{
    const index1D = computeGetGlobalThreadIndices().x;
    const index3D = Unpack1DTo3D(index1D, ClusterUniforms.NumCells.x, ClusterUniforms.NumCells.y);

    if (index1D > ClusterUniforms.NumCells.x * ClusterUniforms.NumCells.y * ClusterUniforms.NumCells.z) { return; }

    const offsetMin = f32x3(index3D.x - ClusterUniforms.NumCells.x * 0.5f, index3D.y - ClusterUniforms.NumCells.y * 0.5f, index3D.z - ClusterUniforms.NumCells.z * 0.5f) * ClusterUniforms.BlockSize.y;
    const offsetMax = f32x3((index3D.x + 1) - ClusterUniforms.NumCells.x * 0.5f, (index3D.y + 1) - ClusterUniforms.NumCells.y * 0.5f, (index3D.z + 1) - ClusterUniforms.NumCells.z * 0.5f) * ClusterUniforms.BlockSize.y;

    // Calculate AABB using min and max
    var aabb : ClusterAABB;
    const eye = ViewConstants.EyePos.xyz;
    aabb.minPoint = f32x4(eye.xyz + offsetMin, 1);
    aabb.maxPoint = f32x4(eye.xyz + offsetMax, 1);
    const extents = (aabb.maxPoint.xyz - aabb.minPoint.xyz) * 0.5f;
    const radius = dot(extents, extents);
    aabb.featureFlags = 0u;
    aabb.minPoint.w = radius;
    aabb.maxPoint.w = sqrt(radius);
    bufferStore(ClusterAABBs, index1D, aabb);
}

//------------------------------------------------------------------------------
/**
*/
@Mask("Cull")
program Cull
{
    ComputeShader = csCull;
};

@Mask("AABBGenerate")
program AABBGenerate
{
    ComputeShader = csClusterAABB;
};

//------------------------------------------------------------------------------
//  @file probe_shared.gpuh
//  @copyright (C) 2024 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------

#include <lib/std.gpuh>
#include <lib/ddgi.gpuh>
struct VolumeData
{
    TemporalRotation : f32x4x4;

    Scale : f32x3;
    Options : u32;

    Offset : f32x3;
    NumIrradianceTexels : i32;

    ProbeGridDimensions : i32x3;
    ProbeIndexStart : i32;

    ProbeScrollOffsets : i32x3;
    ProbeIndexCount : i32;

    Rotation : f32x4;

    ProbeGridSpacing : f32x3;
    NumDistanceTexels : i32;

    MinimalDirections : [32]f32x4;
    ExtraDirections : [1024-32]f32x4;
    Directions : [1024]f32x4;

    InverseGammaEncoding : f32;
    Hysteresis : f32;
    IrradianceGamma : f32;
    RaysPerProbe : u32;
    
    NormalBias : f32;
    ViewBias : f32;
    IrradianceScale : f32;
    DistanceExponent : f32;
    
    ChangeThreshold : f32;
    BrightnessThreshold : f32;
    BackfaceThreshold : f32;
    ProbeDistanceScale : f32;

    MinFrontfaceDistance : f32;
    ProbeIrradiance : u32;
    ProbeDistances : u32;
    ProbeOffsets : u32;

    ProbeStates : u32;
    ProbeScrollSpace : u32;
    ProbeRadiance : u32;
    
    DebugSize : f32;
};

group(SYSTEM_GROUP) uniform VolumeConstants : *VolumeData;

//------------------------------------------------------------------------------
/**
*/
DDGIProbeHash(index : u32) u32
{
	var hash = index;
	hash ^= hash >> 16;
	hash *= 0x85ebca6b;
	hash ^= hash >> 13;
	hash *= 0xc2b2ae35;
	hash ^= hash >> 16;
	return hash;
}

//------------------------------------------------------------------------------
/**
*/
DDGIProbeHashToFloat(hash : u32) f32
{
    return f32(hash) * (1.0 / 4294967296.0); // 1 / 2^32
}

//------------------------------------------------------------------------------
/**
*/
DDGIProbeHashToVec(hash : u32) f32x3
{
    const u = DDGIProbeHashToFloat(DDGIProbeHash(hash));
    const v = DDGIProbeHashToFloat(DDGIProbeHash(hash + 1u));

    const z = 1.0 - 2.0 * u;
    const r = sqrt(max(0.0, 1.0 - z * z));
    const phi = 6.28318530718 * v;

    return f32x3(
        r * cos(phi),
        r * sin(phi),
        z
    );
}

//------------------------------------------------------------------------------
/**
*/
DDGIProbeRandomRotation(index : u32, dir : f32x3) f32x3
{
	const hash = DDGIProbeHash(index);
	const randomDirection = DDGIProbeHashToVec(hash);
	const randomAngle = DDGIProbeHashToFloat(DDGIProbeHash(hash + 17u)) * 6.28318530718; // 2 * pi
	const quat = QuatFromAxisAngle(randomDirection, randomAngle);
	return QuatRotateVector(quat, dir);
}

//------------------------------------------------------------------------------
/**
*/
DDGIGetProbeDirection(rayIndex : i32, probeIndex : u32, rotation : f32x4x4, options : u32) f32x3
{
    var direction : f32x3;
    if ((options & (RELOCATION_OPTION | CLASSIFICATION_OPTION)) != 0)
    {
        const useFixedRays = rayIndex < DDGI_NUM_FIXED_RAYS;
        const adjustedRayIndex = useFixedRays ? rayIndex : rayIndex - DDGI_NUM_FIXED_RAYS;
        direction = useFixedRays ? VolumeConstants.MinimalDirections[adjustedRayIndex].xyz : VolumeConstants.ExtraDirections[adjustedRayIndex].xyz;
        if (useFixedRays)
        {
            return direction;
        }

		direction = DDGIProbeRandomRotation(probeIndex, direction);
    }
    else
    {
        direction = VolumeConstants.Directions[rayIndex].xyz;
    }
    return normalize((rotation * f32x4(direction, 0)).xyz);
}

//------------------------------------------------------------------------------
/**
*/
DDGIThreadBaseCoord(probeIndex : i32, probeGridCounts : i32x3, probeNumTexels : i32) u32x2
{
    const probesPerPlane = DDGIProbesPerPlane(probeGridCounts);
    const planeIndex = probeIndex / probesPerPlane;
    const probeIndexInPlane = probeIndex % probesPerPlane;
    
    const planeWidthInProbes = probeGridCounts.x;
    
    const probeCoordInPlane = i32x2(probeIndexInPlane % planeWidthInProbes, probeIndexInPlane / planeWidthInProbes);
    const baseCoordX = (planeWidthInProbes * planeIndex + probeCoordInPlane.x) * probeNumTexels;
    const baseCoordY = probeCoordInPlane.y * probeNumTexels;
    return u32x2(baseCoordX, baseCoordY);
}

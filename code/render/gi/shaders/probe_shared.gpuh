//------------------------------------------------------------------------------
//  @file probe_shared.gpuh
//  @copyright (C) 2024 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------

#include <lib/std.gpuh>
#include <lib/ddgi.gpuh>
struct VolumeData
{
    TemporalRotation : f32x4x4;

    Scale : f32x3;
    Options : u32;

    Offset : f32x3;
    NumIrradianceTexels : i32;

    ProbeGridDimensions : i32x3;
    ProbeIndexStart : i32;

    ProbeScrollOffsets : i32x3;
    ProbeIndexCount : i32;

    Rotation : f32x4;

    ProbeGridSpacing : f32x3;
    NumDistanceTexels : i32;

    MinimalDirections : [32]f32x4;
    ExtraDirections : [1024-32]f32x4;
    Directions : [1024]f32x4;

    InverseGammaEncoding : f32;
    Hysteresis : f32;
    IrradianceGamma : f32;
    RaysPerProbe : u32;
    
    NormalBias : f32;
    ViewBias : f32;
    IrradianceScale : f32;
    DistanceExponent : f32;
    
    ChangeThreshold : f32;
    BrightnessThreshold : f32;
    BackfaceThreshold : f32;
    ProbeDistanceScale : f32;

    MinFrontfaceDistance : f32;
    ProbeIrradiance : u32;
    ProbeDistances : u32;
    ProbeOffsets : u32;

    ProbeStates : u32;
    ProbeScrollSpace : u32;
    ProbeRadiance : u32;
    
    DebugSize : f32;
};

group(SYSTEM_GROUP) uniform VolumeConstants : *VolumeData;

//------------------------------------------------------------------------------
/**
*/
DDGIGetProbeDirection(rayIndex : i32, rotation : f32x4x4, options : u32) f32x3
{
    var direction : f32x3;
    if ((options & (RELOCATION_OPTION | CLASSIFICATION_OPTION)) != 0)
    {
        const useFixedRays = rayIndex < DDGI_NUM_FIXED_RAYS;
        const adjustedRayIndex = useFixedRays ? rayIndex : rayIndex - DDGI_NUM_FIXED_RAYS;
        direction = useFixedRays ? VolumeConstants.MinimalDirections[adjustedRayIndex].xyz : VolumeConstants.ExtraDirections[adjustedRayIndex].xyz;
        if (useFixedRays)
        {
            return direction;
        }
    }
    else
    {
        direction = VolumeConstants.Directions[rayIndex].xyz;
    }
    return normalize((rotation * f32x4(direction, 0)).xyz);
}

//------------------------------------------------------------------------------
/**
*/
DDGIThreadBaseCoord(probeIndex : i32, probeGridCounts : i32x3, probeNumTexels : i32) u32x2
{
    const probesPerPlane = DDGIProbesPerPlane(probeGridCounts);
    const planeIndex = probeIndex / probesPerPlane;
    const probeIndexInPlane = probeIndex % probesPerPlane;
    
    const planeWidthInProbes = probeGridCounts.x;
    
    const probeCoordInPlane = i32x2(probeIndexInPlane % planeWidthInProbes, probeIndexInPlane / planeWidthInProbes);
    const baseCoordX = (planeWidthInProbes * planeIndex + probeCoordInPlane.x) * probeNumTexels;
    const baseCoordY = probeCoordInPlane.y * probeNumTexels;
    return u32x2(baseCoordX, baseCoordY);
}

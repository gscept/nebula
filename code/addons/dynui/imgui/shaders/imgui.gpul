//------------------------------------------------------------------------------
//  imgui.gpul
//
//  Shader for ImGUI rendering
//
//  (C) 2025 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------

#include "lib/std.gpuh"
#include "lib/shared.gpuh"
#include "lib/defaultsamplers.gpuh"


struct ImGuiData
{
    TextProjectionModel : f32x4x4;
    ColorMask : u32;
    PackedTextureInfo : u32;
    RangeMin : f32;
    RangeMax : f32;
};

@Visibility("VS|PS")
inline ImGUI : *ImGuiData;

group(BATCH_GROUP) sampler_state TextureSampler
{
    Filter = FilterMode.Linear;
};

render_state TextState
{
    BlendEnabled[0] = true;
    SourceBlend[0] = BlendFactor.SourceAlpha;
    DestinationBlend[0] = BlendFactor.OneMinusSourceAlpha;
    DepthWriteEnabled = false;
    DepthTestEnabled = false;
    Cull = CullFace.None;
    ScissorEnabled = true;
};

//------------------------------------------------------------------------------
/**
*/ 
UnpackTexture(val : u32, id : *u32, type : *u32, mip : *u32, layer : *u32, useRange : *u32, useAlpha : *u32, splat : *u32) void
{
    const TEXTURE_TYPE_MASK = 0xFu;
    const TEXTURE_LAYER_MASK = 0xFFu;
    const TEXTURE_MIP_MASK = 0xFu;
    const TEXTURE_USE_RANGE_MASK = 0x1u;
    const TEXTURE_USE_ALPHA_MASK = 0x1u;
    const TEXTURE_SINGLE_CHANNEL = 0x1u;
    const TEXTURE_ID_MASK = 0x7FFu;

    *type = val & TEXTURE_TYPE_MASK;
    *layer = (val >> 4u) & TEXTURE_LAYER_MASK;
    *mip = (val >> 12u) & TEXTURE_MIP_MASK;
    *useRange = (val >> 16u) & TEXTURE_USE_RANGE_MASK;
    *useAlpha = (val >> 17u) & TEXTURE_USE_ALPHA_MASK;
    *splat = (val >> 18u) & TEXTURE_SINGLE_CHANNEL;
    *id = (val >> 19u) & TEXTURE_ID_MASK;
}

//------------------------------------------------------------------------------
/**
*/
UnpackMask(val : u32) f32x4
{
    return f32x4(val & 0x1, (val >> 1) & 0x1, (val >> 2) & 0x1, (val >> 3) & 0x1);
}

//------------------------------------------------------------------------------
/**
*/
entry_point
vsMain(
    binding(0) in position : f32x2,
    binding(1) in uv : f32x2,
    binding(2) in color : f32x4, 
    out UV : f32x2,
    out Color : f32x4) void
{
    const pos = f32x4(position, 0, 1);    
    var projPos = ImGUI.TextProjectionModel * pos;
    projPos.xy -= f32x2(1.0f);
    vertexExportCoordinates(projPos);
    Color = color;
    UV = uv;
}

//------------------------------------------------------------------------------
/** 
*/
entry_point
psMain(
    in UV : f32x2,
    in Color : f32x4) void
{
    var texColor : f32x4;
    var id, type, layer, mip, useAlpha, useRange, splat : u32;
    UnpackTexture(ImGUI.PackedTextureInfo, &id, &type, &mip, &layer, &useRange, &useAlpha, &splat);
    if type == 0 { texColor = sample2DLod(id, TextureSampler, UV, mip); }
    else if type == 1 { texColor = sample2DArrayLod(id, TextureSampler, f32x3(UV, layer), mip); }
    else if type == 2
    {
        const size = textureGetSizeMip(Textures3D[id], mip);
        texColor = sample3DLod(id, TextureSampler, f32x3(UV, layer / f32(size.z)), mip);
    }
    
    if (useRange != 0)
    {
        texColor.rgb = (texColor.rgb - ImGUI.RangeMin) / (ImGUI.RangeMax - ImGUI.RangeMin);
    }

    if useAlpha == 0 { texColor.a = 1.0f; }
    if splat == 1u { texColor.rgba = f32x4(f32x3(texColor.r), 1.0f); }
        
    const mask = UnpackMask(ImGUI.ColorMask);

    // Since we are using sRGB output, remember to degamma
    pixelExportColor(Color * texColor * mask, 0);
}


//------------------------------------------------------------------------------
/**
*/
@Mask("Static")
program Default
{
    VertexShader = vsMain;
    PixelShader = psMain;
    RenderState = TextState;
};
